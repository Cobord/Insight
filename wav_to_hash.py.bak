from scipy.fftpack import fft
from scipy.io import wavfile
import math
import numpy as np

from pyspark import SparkConf, SparkContext
conf = (SparkConf()
        .setMaster("local")
        .setAppName("spectra")
        .set("spark.executor.memory","1g"))
sc = SparkContext(conf=conf)
# the function that extends periodically
# and imposes the right time length
def periodize(signal,len_needed,current_len):
    signal_expanded=np.copy(signal)
    to_expand=int(math.ceil(len_needed/current_len))
    for i in range(to_expand-1):
        signal_expanded=np.append(signal_expanded,signal)
    signal_expanded=signal_expanded[:len_needed]
    return signal_expanded

# read from filename
# make length desiredT by extending periodically
# or cutting off
def modify_raw(filename,desiredT):
    freqs, raw_data = wavfile.read(filename)
    raw_data=raw_data.T[0]
    currentT=len(raw_data)/freqs
    len_needed=desiredT*freqs
    return periodize(raw_data,len_needed,len(raw_data))

# Fourier transform and a simple Gaussian filter
# this assumes fixed rate
# it has been 44k for all files so far
def with_spectrum(filename,desiredT):
    raw_data=modify_raw(filename,desiredT)
    fourier = fft(raw_data)
    length=int(len(fourier)/2)
    fourier=fourier[:length]
    fourier=fourier*[2**(-i*i) for i in range(length)]
    return (filename,fourier)
	
# assume that desiredSteps is smaller than the result of making a desiredT seconds
# long clip
def time_domain_version(filename,desiredT,desiredSteps):
	raw_data=modify_raw(filename,desiredT)
	return (filename,raw_data[:desiredSteps])

# with the Locally Sensitive Hash provided by these files
# for spectrum version
def with_lhs_spectrum(filename,desiredT,all_hyperplanes):
    _, spectra = with_spectrum(filename,desiredT)
    needed_length=all_hyperplanes.shape[1]
    cur_length=len(spectra)
    if (cur_length>needed_length):
        spectra=spectra[:needed_length]
    else:
        spectra=np.append(spectra,np.zeros(needed_length-cur_length))
    return (filename,hash_point(spectra,all_hyperplanes,False))

# similarly for time domain
def with_lhs_time(filename,desiredT,all_hyperplanes):
	needed_length=all_hyperplanes[1]
	_, signal = time_domain_version(filename,desiredT,needed_length)
    return (filename,hash_point(signal,all_hyperplanes,True))
	
# compute the hash
def hash_point(point,all_hyperplanes,is_real):
    if is_real:
        pre_hashed=np.dot(all_hyperplanes,point)
        return list(map(lambda x: x>=0,pre_hashed))
    else:
        pre_hashed=np.dot(all_hyperplanes,point)-point[0]
        hashed=list(map(lambda x: [np.real(x)>=0,np.imag(x)>=0],pre_hashed))
        return [item for sublist in hashed for item in sublist]

def construct_hyperplanes(num_hyperplanes,ambient_dimension,is_real):
    all_hyperplanes=np.random.randn(num_hyperplanes,ambient_dimension-1)
    if (not is_real):
        all_hyperplanes=all_hyperplanes+1j*np.random.randn(num_hyperplanes,ambient_dimension-1)
        all_hyperplanes=np.hstack((np.ones((num_hyperplanes,1)),all_hyperplanes))
    else:
        all_hyperplanes=np.hstack((np.random.randn(num_hyperplanes,1),all_hyperplanes))
    return all_hyperplanes

def swap_and_simplify(filename,res):
    res_as_num=np.array([int(res[i])<<i for i in range(len(res))]).sum()
    return (res_as_num,filename)

times_hashed=1
num_points=10
desiredT=30
#_,y=with_spectrum("wavFiles/aerosol-can-spray-01.wav",desiredT)
_,y=time_domain_version("wavFiles/aerosol-can-spray-01.wav",desiredT,1000000) # slightly below the 1.32 for 44 kHz of desiredT=30
all_hyperplanes=construct_hyperplanes(int(np.log2(num_points)),len(y),False)
# append another copy of all_hyperplanes with different randomness
#  for each times_hashed

sample_rate=.05
#prefix="hdfs://ec2-54-82-213-27.compute-1.amazonaws.com:9000/user/wavFiles/"
prefix="wavFiles/"
#out_destination="hdfs://ec2-54-82-213-27.compute-1.amazonaws.com:9000/user/saved_lhs_output"
out_destination="saved_lhs_output"
#result=sc.textFile("wavFilesList2.txt").map(lambda name: prefix+name).sample(False,sample_rate,None).map(lambda file: with_lhs_spectrum(file,desiredT,all_hyperplanes)).map(lambda (filename, res): swap_and_simplify(filename,res))
result=sc.textFile("wavFilesList2.txt").map(lambda name: prefix+name).sample(False,sample_rate,None).map(lambda file: with_lhs_time(file,desiredT,all_hyperplanes)).map(lambda (filename, res): swap_and_simplify(filename,res))
result.map(lambda (res,filename): str(res)+","+filename).saveAsTextFile(out_destination)

def candidate_neighbors(input_file):
	_, hash_point=with_lhs_time(input_file,desiredT,all_hyperplanes)
	hash_point,_ = swap_and_simplify(None,hash_point)
	return result.filter(lambda (res,filename): res==hash_point).collect()